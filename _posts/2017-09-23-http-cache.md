---
layout: post
title: "HTTP缓存机制介绍"
date: 2017-09-22 16:23:32
categories: http
tags: http cache web
comments: true
---

这是前端时间做的一次分享, 起因是我们的网站在更新的时候若js等有变动, 需要用户强刷才能获取最新内容, 借这个机会了解了HTTP缓存的机制. 本文的主要内容基本上取自RFC-7234, 翻译整理加自己的理解, 加上一些其他资料和图片.

* TOC
{:toc}

## 提出问题
- 为什么要清除缓存/强刷?
  - 简单说原因就是因为浏览器缓存了旧版本的文件, 在打开页面时直接使用缓存, 没有向服务器发起对 新部署上的文件的请求, 所以需要强刷.
- 为什么要缓存? 
  - HTTP缓存的设计 一是为了节省带宽流量资源. 二是为了减少浏览器打开页面的响应时间.
- 如何做的缓存? 后文解答
- 强刷是什么? 后文解答

## 划清范围
本文中"缓存"一词, 特指在HTTP协议相关的, 出现在浏览器, 中间代理服务器上的, 对于HTTP响应消息的缓存, 不涉及其他的如网关层,CDN,后端负载均衡等处的缓存.

HTTP缓存, 从类型上分两种shared cache / private cache, 前者可被中间代理和浏览器缓存,后者只能被浏览器缓存.

![缓存类型](/resources/HTTPCachtType.png)

这两种缓存除使用范围限制, 其他没什么不同, 下文基本不做区分.

关于缓存的控制, 主要是服务器和浏览器之间, 通过请求和响应的一些header来进行交互的, 所以本文的介绍过程中会穿插着介绍一些相关的header, 最后总结.

## 缓存定义
在指南中对HTTP Cache做了如下定义:

- a local store of response messages
- the subsystem that controls storage, retrieval, and deletion of messages in it.

## 存的是什么
HTTP缓存是一种类似KV的storage.

基本的Key是由请求方法和目标URI构成的. 由于目前主要缓存GET请求的响应, 所以在chrome等浏览器中, 缓存的key只由uri构成.
value则是对应的key, 在之前发起请求时得到的响应消息.

(value可能是多条, 这就涉及二级Key (secondary key: 当content negotiation时, 使用Vary特定header作为二级key,[后文](附加内容1-vary-header和缓存的二级key)详细介绍))

在chrome浏览器可以通过 chrome://cache/ 页面来查看当前的所有缓存

![chrome缓存页面](/resources/chrome-cache.png)

点进其中每一条, 就可以看到对应的被缓存的HTTP响应消息.

## 何时存(缓存先决条件)
因为RFC只是一份指南, 而具体的细节取决于其实现, 也就是说浏览器有很多自己控制的空间. 对于何时缓存, RFC 7234中使用这样的词汇: "MUST NOT store a response to any request, unless:", 就是说除非以下这些条件都满足, 否则不能缓存, 但是满足了这些条件, 浏览器到底要不要缓存却不一定. 我们来看一下这些条件:

- 特定的请求方法(GET,HEAD, POST(post只有显式的设置才会缓存))     且
- public cache时, 不能是Authentication的    且
- private cache时, 不能被中间代理缓存    且
- 响应没有no-store指令    且
- 特定的Headers符合条件:
  - Expires header      或
  - Cache Control header 中
  - 包含max-age/s-maxage指令     或
  - 包含public指令    或
  - `扩展指令`表示允许缓存    或
  - 特定的返回code( 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501) 

前几条要求都是比较好理解的, 也比较容易满足. 而第5条下面的各个"或"的要求中, 只要返回码是200等, 就能缓存. 哇, 这就意味着, 大多数请求, 按规定都是可以缓存的, 这刷新了我以前"只有CSS/JS/图片才会缓存"的认知.

## 何时用
响应被缓存后, 什么时候,什么条件下才能被采用呢? 当一条新的请求要发出前, 浏览器要判断这些条件(When presented with a request, a cache MUST NOT reuse a stored response, unless):

- uri  match stored response     且
- 请求方法运行    且
- 当前请求的Header满足 对应缓存响应的Vary的要求    且
- 请求没有no-cache指令     且
- 对应的被缓存的响应是:
  - 新鲜的[(fresh)](#名词解释)   或
  - 被允许在不新鲜(stale)时 提供服务(主要是无法连接到原始服务的情况)      或
  - 成功验证过的(validated)

这些条件综合起来看, 就是用请求的uri作为key去缓存中查找到了对应的响应, 且响应的过期时间满足条件(所谓新鲜不新鲜,就是指过期时间). 新鲜问题是下一节的内容.

## 何时删除/过期
   删除和过期是两个操作, 缓存过期了, 浏览器默认也不会删除, 除非存储空间不足, 可能会使用LRU之类的策略清除一些.
   
   过期的问题, 或者说新鲜的问题, 就像是我们食品的”保质期”问题一样, 这个问题是关于缓存问题的唯一难点和重点.
   
   一个关于缓存是否新鲜/过期的简单公式
   
   ```response_is_fresh = (freshness_lifetime > current_age)```
   
  就是说是否新鲜 =  保质期限 是否大于 已出现/已被生产的时间.
  
  ### 关于一条缓存的保质期有多长, 有两种方式设置:
  
  - **显式的设置过期时间**
  
    > 通过xx header
  
  - **启发式的计算过期**
  
    我以前一直有个疑问, 响应header里没有缓存时间相关的内容, 也就是服务器就没有设置过期时间, 这时候怎么办?
     
    答案是 浏览器收到没有设置过期时间的响应时, 可以根据自己的算法来启发式的计算过期时间. 怎么计算呢, 一个典型的算法是
    
    ```freshness_lifetime = (date_value - last_modified_value) * 0.10 ```
    这个算式就是**当前**时间 减去 上次修改时间 乘 0.1, 效果就是当前离这个文件(响应)的上次修改时间越久, 那么保质期设置的越长, 浏览器就是认为越久没改动的文件, 改动的频度越小.
    
    感兴趣的同学可以看[chromium源码](https://chromium.googlesource.com/chromium/src/+/49.0.2606.2/net/http/http_response_headers.cc#1001)中对于这部分的处理.
    
  ### 关于一条缓存已出现/已被生产了多久, 即age问题:
  首先关于某条响应消息(比如一个css资源)真实生产了多久, 浏览器是难以知道的. 所以现在有两种方式可供浏览器来确定, 在它接到一条响应资源时,该资源的已有Age.
  
  - 表面上的Age:
   
      ```apparent_age = max(0, response_time - date_value);``` 
      
      > Date Header:
  
  - 修正的Age Value:
  
      ```
      response_delay = response_time - request_time;
      corrected_age_value = age_value + response_delay;
      ```
      
      > Age Header:
  
  而实际上, 浏览器会取这两者中的较大者, 作为浏览器收到这条响应时, 它已经具有的初始Age. 即:
  ```corrected_initial_age = max(apparent_age, corrected_age_value);```
  
  接下来用```resident_time = now - response_time;
              current_age = corrected_initial_age + resident_time;``` 初始Age加上 它在本缓存系统中待的时间, 就是这条缓存的当前Age了.
              
  我弄了幅图来展示Age的问题:
  
  ![Age计算](/resources/cache-age.png)
              
  (其实我一直在思考, 为什么不用Last-Modified的值来帮助计算Age? 有想法的可以分享一下) 
  
  ok, 一条缓存的保质期多长可以知道了, 当前Age也知道了, 那么这条缓存是否过期/新鲜, 就如前所说比较一下就好了.
  
  那么假如一条缓存消息过期了, 前面我也提到了, 浏览器默认是不会删除的, 那他留着干嘛用啊. 其实过期不删是因为, 浏览器可以发起一个**验证**过程为它续命.
  
  ### 验证 [(validation)](#名词解释) 
  
  验证是通过条件请求实现的(RFC7232:conditional request mechanism).
  
## 相关Header

  - Cache-Control: 关于缓存控制的超强Header.他的值不是单一的, 而是逗号分隔的kv形式. 比如`cache-control:public, max-age=31536000`. 
      也就是说他的值里又有key, cache-control值里的key叫做指令, 比如max-age指令等.除了基本的规定好的一些指令, 指南还指出, 可以在这里添加自己的自定义指令, 指令含义和实现自己弄去.
      
      我们只说Cache-Control的一些基本指令:
 

## 名词解释
- `Fresh` : 新鲜的 A stored response is considered “fresh"  if the response can be reused without “validation”.
- `Stale` : 不新鲜的
- `validation` : 验证 
- `age` : 年龄 A response’s age is the time that has passed since it was generated by, or successfully validated with, the origin server.
- `cache eviction` : 缓存逐出 Caches have finite storage so items are periodically removed from storage
- `selecting header` : 是指响应的Vary头的值里指定的header

## 附加内容1: Vary Header和缓存的二级Key

